<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>BFS, DFS & Tree Algorithms - Master Guide</title>
    <style>
        body {
            font-family: 'DejaVu Sans', 'Arial', sans-serif;
            max-width: 8.5in;
            margin: 0 auto;
            padding: 1in;
            line-height: 1.6;
            color: #333;
        }
        code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', 'Monaco', monospace;
            font-size: 0.9em;
        }
        pre {
            background-color: #f4f4f4;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            border-left: 4px solid #4CAF50;
        }
        pre code {
            background-color: transparent;
            padding: 0;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
            page-break-inside: avoid;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        th {
            background-color: #4CAF50;
            color: white;
            font-weight: bold;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #4CAF50;
            padding-bottom: 10px;
            page-break-after: avoid;
        }
        h2 {
            color: #34495e;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 5px;
            margin-top: 30px;
            page-break-after: avoid;
        }
        h3 {
            color: #555;
            margin-top: 25px;
            page-break-after: avoid;
        }
        @media print {
            body {
                padding: 0.5in;
            }
            pre, table {
                page-break-inside: avoid;
            }
            h1, h2, h3 {
                page-break-after: avoid;
            }
        }
    </style>
</head>
<body>
<h1>üå≥ BFS, DFS &amp; Tree Algorithms - Complete Master Guide</h1>
<h2>Interactive Workbook for Offline Study</h2>
<p><strong>Author:</strong> Interview Prep Materials<br />
<strong>Last Updated:</strong> 2025<br />
<strong>Estimated Study Time:</strong> 8-10 hours</p>
<p><strong>This comprehensive guide covers:</strong>
- BFS (Breadth-First Search) fundamentals &amp; applications
- DFS (Depth-First Search) fundamentals &amp; applications<br />
- Tree algorithms &amp; traversal techniques
- Binary tree problem-solving patterns
- Advanced tree algorithms</p>
<hr />
<h1>Table of Contents</h1>
<ol>
<li><a href="#bfs-core-concepts">BFS Core Concepts</a></li>
<li><a href="#bfs-exercises">BFS Exercises</a></li>
<li><a href="#dfs-core-concepts">DFS Core Concepts</a></li>
<li><a href="#dfs-exercises">DFS Exercises</a></li>
<li><a href="#tree-algorithms-fundamentals">Tree Algorithms Fundamentals</a></li>
<li><a href="#tree-traversal-techniques">Tree Traversal Techniques</a></li>
<li><a href="#tree-problem-patterns">Tree Problem Patterns</a></li>
<li><a href="#advanced-tree-algorithms">Advanced Tree Algorithms</a></li>
<li><a href="#comparison--decision-making">Comparison &amp; Decision Making</a></li>
<li><a href="#practice-problems">Practice Problems</a></li>
<li><a href="#answer-key">Answer Key</a></li>
</ol>
<hr />
<h1>Part 1: BFS Core Concepts</h1>
<h2>üåä Understanding BFS: The Ripple Analogy</h2>
<p><strong>Fill in the blanks:</strong></p>
<ol>
<li>Imagine dropping a stone in a pond. BFS works like ripples:</li>
<li>First, the ripple touches everything <strong>______ steps away</strong></li>
<li>Then, everything <strong>______ steps away</strong></li>
<li>Then <strong>______ steps away</strong></li>
<li>
<p>And so on...</p>
</li>
<li>
<p>BFS explores nodes <strong><strong><em>_</em>_ by </strong>____</strong>, in order of <strong>______</strong> from the start.</p>
</li>
<li>
<p>BFS is perfect for finding the <strong>______</strong> path in unweighted graphs.</p>
</li>
<li>
<p>BFS uses a <strong>______</strong> (FIFO - First In, First Out).</p>
</li>
<li>
<p>BFS explores <strong>______</strong> (level by level / as deep as possible).</p>
</li>
</ol>
<h2>üìù BFS Algorithm Steps</h2>
<p><strong>Complete the steps:</strong></p>
<ol>
<li><strong>Initialize:</strong></li>
<li>Create a <strong>______</strong> (queue)</li>
<li>Create a <strong>______</strong> (visited set)</li>
<li>
<p>Add the <strong>______</strong> node to both</p>
</li>
<li>
<p><strong>Main Loop:</strong></p>
</li>
<li>
<p>While queue is <strong>______</strong>:</p>
<ul>
<li><strong>______</strong> a node from the queue (this is the oldest node)</li>
<li><strong>______</strong> the node (do your work here)</li>
<li>For each <strong>______</strong> of the current node:</li>
<li>If neighbor is <strong>______</strong> visited:<ul>
<li><strong>______</strong> it as visited (BEFORE adding to queue!)</li>
<li>Add it to the <strong>______</strong></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Key Rule:</strong> Always mark nodes as visited <strong>______</strong> (before/after) adding to the queue to avoid duplicates.</p>
</li>
</ol>
<h2>üÜö BFS vs DFS Comparison Table</h2>
<p><strong>Fill in the table:</strong></p>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>BFS</th>
<th>DFS</th>
</tr>
</thead>
<tbody>
<tr>
<td>Data Structure</td>
<td><strong>______</strong></td>
<td><strong>______</strong></td>
</tr>
<tr>
<td>Exploration Order</td>
<td><strong>______</strong></td>
<td><strong>______</strong></td>
</tr>
<tr>
<td>Finds</td>
<td><strong>______</strong> path</td>
<td><strong>______</strong> path</td>
</tr>
<tr>
<td>Memory Usage</td>
<td><strong>______</strong></td>
<td><strong>______</strong></td>
</tr>
<tr>
<td>Good For</td>
<td><strong>______</strong></td>
<td><strong>______</strong></td>
</tr>
</tbody>
</table>
<hr />
<h1>Part 2: BFS Exercises</h1>
<h2>Exercise 1: Basic BFS Template - Fill in the Code</h2>
<pre><code class="language-python">def bfs_basic(graph: Dict, start) -&gt; Set:
    &quot;&quot;&quot;
    Basic BFS traversal of a graph.

    TODO: Fill in the missing code
    &quot;&quot;&quot;
    visited = {start}
    queue = ________________  # Fill in: initialize queue with start

    while ________________:  # Fill in: condition
        node = queue.________________  # Fill in: remove node from queue

        # Process node here (optional)
        # ...

        for neighbor in graph[node]:
            if neighbor ________________ visited:  # Fill in: check condition
                visited.________________  # Fill in: mark as visited
                queue.________________  # Fill in: add to queue

    return visited
</code></pre>
<h2>Exercise 2: BFS with Level Tracking - Complete the Code</h2>
<pre><code class="language-python">def bfs_with_levels(graph: Dict, start) -&gt; Dict:
    &quot;&quot;&quot;
    BFS that tracks distance/level for each node.

    TODO: Complete the implementation
    &quot;&quot;&quot;
    levels = {start: 0}
    queue = deque([start])

    while queue:
        node = ________________
        current_level = levels[node]

        for neighbor in graph[node]:
            if neighbor ________________ levels:
                levels[neighbor] = ________________  # Fill in: calculate level
                queue.________________  # Fill in: add to queue

    return levels
</code></pre>
<h2>Exercise 3: BFS on Grid - Complete the Code</h2>
<pre><code class="language-python">def bfs_grid(grid: List[List[int]], start: Tuple[int, int]) -&gt; int:
    &quot;&quot;&quot;
    BFS on a 2D grid to find shortest path.

    TODO: Fill in the missing parts
    &quot;&quot;&quot;
    rows, cols = len(grid), len(grid[0])
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # up, down, left, right
    visited = {start}
    queue = deque([(start[0], start[1], 0)])  # (row, col, distance)

    while queue:
        r, c, dist = ________________

        # Check if reached target (example: value == 9)
        if grid[r][c] == 9:
            return ________________

        # Explore neighbors
        for dr, dc in directions:
            nr, nc = ________________, ________________  # Fill in: new row, new col

            # Check bounds and validity
            if (0 &lt;= nr &lt; rows and 0 &lt;= nc &lt; cols and 
                (nr, nc) ________________ visited and 
                grid[nr][nc] != 0):  # 0 is obstacle

                visited.add((nr, nc))
                queue.append((________________, ________________, ________________))  # Fill in

    return -1  # Not found
</code></pre>
<h2>Exercise 4: BFS Shortest Path with Reconstruction</h2>
<pre><code class="language-python">def bfs_shortest_path(graph: Dict, start, end) -&gt; List:
    &quot;&quot;&quot;
    Find shortest path between start and end using BFS.

    TODO: Complete the path reconstruction
    &quot;&quot;&quot;
    if start == end:
        return [start]

    visited = {start}
    queue = deque([start])
    parent = {}  # Track parent: {node: parent_node}

    while queue:
        current = queue.popleft()

        for neighbor in graph.get(current, []):
            if neighbor ________________ visited:
                visited.________________
                parent[neighbor] = ________________  # Fill in: track parent
                queue.________________

                if neighbor == end:
                    # Reconstruct path
                    path = []
                    node = end
                    while node ________________ None:  # Fill in: condition
                        path.append(node)
                        node = parent.________________  # Fill in: get parent

                    return path[::-1]  # Reverse

    return []  # No path found
</code></pre>
<h2>Quiz 1: BFS Understanding</h2>
<p><strong>Answer the following questions:</strong></p>
<ol>
<li><strong>Why does BFS guarantee the shortest path in unweighted graphs?</strong></li>
</ol>
<p>Your answer:</p>
<hr />
<hr />
<ol>
<li><strong>When should you mark a node as visited in BFS?</strong></li>
<li>[ ] Before adding to queue</li>
<li>[ ] After removing from queue</li>
<li>[ ] Both are correct</li>
<li>[ ] Neither matters</li>
</ol>
<p>Your answer: <strong>______</strong></p>
<ol>
<li><strong>What is the time complexity of BFS?</strong></li>
<li>[ ] O(V)</li>
<li>[ ] O(E)</li>
<li>[ ] O(V + E)</li>
<li>[ ] O(V √ó E)</li>
</ol>
<p>Your answer: <strong>______</strong></p>
<ol>
<li><strong>What is the space complexity of BFS?</strong></li>
<li>[ ] O(V)</li>
<li>[ ] O(E)</li>
<li>[ ] O(V + E)</li>
<li>[ ] O(V¬≤)</li>
</ol>
<p>Your answer: <strong>______</strong></p>
<ol>
<li><strong>Draw the BFS traversal order for this graph starting at A:</strong>
   <code>A
       / \
      B   C
     / \ / \
    D   E   F</code></li>
</ol>
<p>Traversal order: <strong><strong><em>_</em>_ ‚Üí </strong><strong><em>_ ‚Üí </em></strong><strong><em> ‚Üí </em></strong><strong><em> ‚Üí </em></strong><strong><em> ‚Üí </em></strong>___</strong></p>
<hr />
<h1>Part 3: DFS Core Concepts</h1>
<h2>üï≥Ô∏è Understanding DFS: The Maze Explorer Analogy</h2>
<p><strong>Fill in the blanks:</strong></p>
<ol>
<li>DFS works like exploring a maze:</li>
<li>Pick a path and go as <strong>______</strong> as possible</li>
<li>When you hit a dead end, <strong>______</strong> to the last choice point</li>
<li>
<p>Keep going <strong>______</strong> until you've explored everything</p>
</li>
<li>
<p>DFS explores nodes by going <strong>______</strong> first, then <strong>______</strong>.</p>
</li>
<li>
<p>DFS is perfect for:</p>
</li>
<li><strong>______</strong> all paths</li>
<li><strong>______</strong> problems (permutations, combinations)</li>
<li><strong>______</strong> cycles</li>
<li>
<p><strong>______</strong> sorting</p>
</li>
<li>
<p>DFS uses a <strong>______</strong> (LIFO - Last In, First Out) or <strong>______</strong>.</p>
</li>
<li>
<p>DFS stores only the <strong>______</strong> path, making it more memory-efficient.</p>
</li>
</ol>
<h2>üìù DFS Algorithm Steps (Recursive)</h2>
<p><strong>Complete the steps:</strong></p>
<ol>
<li><strong>Base Case:</strong></li>
<li>
<p>If node is <strong>______</strong> or <strong>______</strong>: return</p>
</li>
<li>
<p><strong>Process Current Node:</strong></p>
</li>
<li><strong>______</strong> node as visited</li>
<li>
<p><strong>______</strong> the node (do your work here)</p>
</li>
<li>
<p><strong>Recursive Step:</strong></p>
</li>
<li>For each <strong>______</strong>:<ul>
<li>If neighbor is <strong>______</strong> visited:</li>
<li>Recursively call <strong>______</strong> on neighbor</li>
</ul>
</li>
</ol>
<h2>üìù DFS Algorithm Steps (Iterative)</h2>
<p><strong>Complete the steps:</strong></p>
<ol>
<li><strong>Initialize:</strong></li>
<li>Create a <strong>______</strong> (stack)</li>
<li>Create a <strong>______</strong> (visited set)</li>
<li>
<p>Push the <strong>______</strong> node</p>
</li>
<li>
<p><strong>Main Loop:</strong></p>
</li>
<li>While stack is <strong>______</strong>:<ul>
<li><strong>______</strong> a node from the stack</li>
<li>If node is <strong>______</strong> visited:</li>
<li><strong>______</strong> it as visited</li>
<li><strong>______</strong> the node</li>
<li>Push all <strong>______</strong> to the stack</li>
</ul>
</li>
</ol>
<h2>üîë Key DFS Patterns</h2>
<p><strong>Match the pattern with its use case:</strong></p>
<ol>
<li><strong>Inorder (Left ‚Üí Root ‚Üí Right)</strong> ‚Üí <strong>______</strong></li>
<li><strong>Preorder (Root ‚Üí Left ‚Üí Right)</strong> ‚Üí <strong>______</strong></li>
<li><strong>Postorder (Left ‚Üí Right ‚Üí Root)</strong> ‚Üí <strong>______</strong></li>
</ol>
<p>Choices:
- A. Copy/serialize tree
- B. BST gives sorted order
- C. Delete tree/calculate size</p>
<hr />
<h1>Part 4: DFS Exercises</h1>
<h2>Exercise 5: Recursive DFS Template - Fill in the Code</h2>
<pre><code class="language-python">def dfs_recursive(graph: Dict, node, visited: Set) -&gt; None:
    &quot;&quot;&quot;
    Recursive DFS traversal.

    TODO: Complete the implementation
    &quot;&quot;&quot;
    # Base case
    if node ________________ visited:
        return

    # Mark as visited
    visited.________________

    # Process node (optional)
    # process(node)

    # Recursive call on neighbors
    for neighbor in graph.get(node, []):
        if neighbor ________________ visited:
            ________________  # Fill in: recursive call
</code></pre>
<h2>Exercise 6: Iterative DFS Template - Fill in the Code</h2>
<pre><code class="language-python">def dfs_iterative(graph: Dict, start) -&gt; Set:
    &quot;&quot;&quot;
    Iterative DFS using a stack.

    TODO: Complete the implementation
    &quot;&quot;&quot;
    visited = set()
    stack = ________________  # Fill in: initialize stack with start

    while ________________:  # Fill in: condition
        node = stack.________________  # Fill in: remove from stack

        if node ________________ visited:  # Fill in: check
            visited.________________  # Fill in: mark as visited

            # Process node (optional)
            # process(node)

            # Add neighbors to stack
            for neighbor in graph.get(node, []):
                if neighbor ________________ visited:
                    stack.________________  # Fill in: add to stack

    return visited
</code></pre>
<h2>Exercise 7: DFS on Grid - Complete the Code</h2>
<pre><code class="language-python">def dfs_grid(grid: List[List[int]], r: int, c: int, visited: Set) -&gt; int:
    &quot;&quot;&quot;
    DFS on grid to count connected cells or find islands.

    TODO: Fill in the missing parts
    &quot;&quot;&quot;
    rows, cols = len(grid), len(grid[0])

    # Base case: out of bounds or invalid
    if (r &lt; 0 or r &gt;= rows or 
        c &lt; 0 or c &gt;= cols or
        (r, c) ________________ visited or
        grid[r][c] == 0):  # 0 is water/obstacle
        return 0

    # Mark as visited
    visited.add((r, c))
    count = 1  # Count current cell

    # Explore all 4 directions
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    for dr, dc in directions:
        count += dfs_grid(grid, ________________, ________________, visited)  # Fill in

    return count
</code></pre>
<h2>Exercise 8: DFS with Path Tracking - Complete the Code</h2>
<pre><code class="language-python">def dfs_with_path(graph: Dict, start, end, path: List, visited: Set) -&gt; bool:
    &quot;&quot;&quot;
    DFS that tracks the path from start to end.

    TODO: Complete the path tracking
    &quot;&quot;&quot;
    # Base case: reached target
    if start == end:
        path.append(end)
        return ________________  # Fill in

    # Mark as visited
    visited.add(start)
    path.append(start)

    # Explore neighbors
    for neighbor in graph.get(start, []):
        if neighbor ________________ visited:
            if dfs_with_path(________________, ________________, ________________, path, visited):  # Fill in
                return True

    # Backtrack: remove from path
    path.________________  # Fill in: remove last element
    return False
</code></pre>
<h2>Exercise 9: DFS Backtracking Template - Complete the Code</h2>
<pre><code class="language-python">def dfs_backtrack(candidates: List, path: List, result: List) -&gt; None:
    &quot;&quot;&quot;
    DFS backtracking template (for permutations/combinations).

    TODO: Complete the backtracking logic
    &quot;&quot;&quot;
    # Base case: found a solution
    if is_complete(path):
        result.append(path[:])  # Make a copy
        return

    # Try all candidates
    for candidate in candidates:
        # Skip invalid candidates
        if not is_valid(candidate, path):
            continue

        # Choose
        path.append(candidate)

        # Explore
        dfs_backtrack(________________, ________________, ________________)  # Fill in

        # Unchoose (backtrack)
        path.________________  # Fill in: remove last element
</code></pre>
<h2>Exercise 10: DFS Cycle Detection - Complete the Code</h2>
<pre><code class="language-python">def has_cycle_directed(graph: Dict) -&gt; bool:
    &quot;&quot;&quot;
    Detect cycle in a directed graph using DFS.

    TODO: Complete the cycle detection logic
    Uses 3 states: WHITE (unvisited), GRAY (in current path), BLACK (finished)
    &quot;&quot;&quot;
    # Color states: 0 = WHITE (unvisited), 1 = GRAY (visiting), 2 = BLACK (done)
    color = {node: 0 for node in graph}

    def dfs(node):
        if color[node] == 1:  # GRAY = cycle found!
            return ________________  # Fill in

        if color[node] == 2:  # BLACK = already processed
            return ________________  # Fill in

        # Mark as GRAY (in current path)
        color[node] = ________________  # Fill in

        # Explore neighbors
        for neighbor in graph.get(node, []):
            if dfs(neighbor):
                return ________________  # Fill in

        # Mark as BLACK (finished)
        color[node] = ________________  # Fill in
        return False

    # Check all nodes (for disconnected components)
    for node in graph:
        if color[node] == 0:  # WHITE
            if dfs(node):
                return True

    return False
</code></pre>
<h2>Exercise 11: DFS Topological Sort - Complete the Code</h2>
<pre><code class="language-python">def topological_sort(graph: Dict) -&gt; List:
    &quot;&quot;&quot;
    Topological sort using DFS.

    TODO: Complete the topological sort
    Returns nodes in order such that if u ‚Üí v, then u comes before v.
    &quot;&quot;&quot;
    visited = set()
    result = []

    def dfs(node):
        if node ________________ visited:  # Fill in: check if already in result
            return

        visited.add(node)

        # Explore dependencies (neighbors that must come AFTER)
        for neighbor in graph.get(node, []):
            if neighbor ________________ visited:  # Fill in
                ________________  # Fill in: recursive call

        # Add to result (postorder: after exploring dependencies)
        result.________________  # Fill in: add node

    # Process all nodes
    for node in graph:
        if node ________________ visited:  # Fill in
            dfs(node)

    return result[::-1]  # Reverse (we added in reverse order)
</code></pre>
<h2>Exercise 12: DFS Tree Traversals - Complete the Code</h2>
<pre><code class="language-python">class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def inorder_traversal(root: Optional[TreeNode]) -&gt; List[int]:
    &quot;&quot;&quot;
    Inorder: Left ‚Üí Root ‚Üí Right

    TODO: Complete the inorder traversal
    &quot;&quot;&quot;
    result = []

    def inorder(node):
        if node:
            inorder(________________)  # Fill in: traverse left
            result.append(________________)  # Fill in: process root
            inorder(________________)  # Fill in: traverse right

    inorder(root)
    return result

def preorder_traversal(root: Optional[TreeNode]) -&gt; List[int]:
    &quot;&quot;&quot;
    Preorder: Root ‚Üí Left ‚Üí Right

    TODO: Complete the preorder traversal
    &quot;&quot;&quot;
    result = []

    def preorder(node):
        if node:
            result.append(________________)  # Fill in: process root FIRST
            preorder(________________)  # Fill in: traverse left
            preorder(________________)  # Fill in: traverse right

    preorder(root)
    return result

def postorder_traversal(root: Optional[TreeNode]) -&gt; List[int]:
    &quot;&quot;&quot;
    Postorder: Left ‚Üí Right ‚Üí Root

    TODO: Complete the postorder traversal
    &quot;&quot;&quot;
    result = []

    def postorder(node):
        if node:
            postorder(________________)  # Fill in: traverse left
            postorder(________________)  # Fill in: traverse right
            result.append(________________)  # Fill in: process root LAST

    postorder(root)
    return result
</code></pre>
<h2>Exercise 13: DFS Generate Parentheses - Complete the Code</h2>
<pre><code class="language-python">def generate_parentheses(n: int) -&gt; List[str]:
    &quot;&quot;&quot;
    Generate all valid combinations of n pairs of parentheses using DFS backtracking.

    Example: n=2 ‚Üí [&quot;(())&quot;, &quot;()()&quot;]

    TODO: Complete the backtracking logic
    &quot;&quot;&quot;
    result = []

    def dfs(open_count: int, close_count: int, current: str):
        # Base case: valid combination found
        if len(current) == ________________:  # Fill in: target length
            result.append(current)
            return

        # Can add opening parenthesis if we haven't used all
        if open_count &lt; n:
            dfs(________________, ________________, ________________)  # Fill in: add '('

        # Can add closing parenthesis if we have more open than close
        if close_count &lt; ________________:  # Fill in: condition
            dfs(________________, ________________, ________________)  # Fill in: add ')'

    dfs(0, 0, &quot;&quot;)
    return result
</code></pre>
<h2>Exercise 14: DFS Word Search - Complete the Code</h2>
<pre><code class="language-python">def word_search(board: List[List[str]], word: str) -&gt; bool:
    &quot;&quot;&quot;
    Check if word exists in grid by moving adjacent (up, down, left, right).

    TODO: Complete the DFS backtracking logic
    &quot;&quot;&quot;
    rows, cols = len(board), len(board[0])

    def dfs(r: int, c: int, index: int) -&gt; bool:
        # Base case: found entire word
        if index == ________________:  # Fill in: target index
            return ________________  # Fill in

        # Out of bounds or doesn't match
        if (r &lt; 0 or r &gt;= rows or 
            c &lt; 0 or c &gt;= cols or
            board[r][c] != word[index]):
            return ________________  # Fill in

        # Mark as visited (use special char)
        temp = board[r][c]
        board[r][c] = ________________  # Fill in: mark visited

        # Explore 4 directions
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        found = False
        for dr, dc in directions:
            if dfs(________________, ________________, ________________):  # Fill in
                found = True
                break

        # Backtrack: restore original value
        board[r][c] = ________________  # Fill in: restore

        return found

    # Try starting from each cell
    for r in range(rows):
        for c in range(cols):
            if dfs(r, c, 0):
                return True

    return False
</code></pre>
<h2>Exercise 15: DFS Number of Islands - Complete the Code</h2>
<pre><code class="language-python">def num_islands(grid: List[List[str]]) -&gt; int:
    &quot;&quot;&quot;
    Count number of islands (connected '1's) using DFS.

    TODO: Complete the island counting logic
    &quot;&quot;&quot;
    if not grid:
        return 0

    rows, cols = len(grid), len(grid[0])
    count = 0

    def dfs(r: int, c: int):
        # Base case: out of bounds or water
        if (r &lt; 0 or r &gt;= rows or 
            c &lt; 0 or c &gt;= cols or
            grid[r][c] != '1'):
            return

        # Mark as visited (sink the island)
        grid[r][c] = '0'

        # Explore all 4 directions
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        for dr, dc in directions:
            dfs(________________, ________________)  # Fill in

    # Find all islands
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == '1':
                count += ________________  # Fill in
                dfs(r, c)

    return count
</code></pre>
<h2>Exercise 16: DFS Permutations - Complete the Code</h2>
<pre><code class="language-python">def permutations(nums: List[int]) -&gt; List[List[int]]:
    &quot;&quot;&quot;
    Generate all permutations using DFS backtracking.

    Example: [1,2] ‚Üí [[1,2], [2,1]]

    TODO: Complete the backtracking logic
    &quot;&quot;&quot;
    result = []

    def dfs(current: List[int], remaining: List[int]):
        # Base case: permutation complete
        if len(remaining) == 0:
            result.append(________________)  # Fill in: add copy of current
            return

        # Try each remaining number
        for i in range(len(remaining)):
            # Choose
            current.append(________________)  # Fill in: add number
            new_remaining = remaining[:i] + remaining[________________:]  # Fill in: remove chosen

            # Explore
            dfs(current, new_remaining)

            # Unchoose (backtrack)
            current.________________  # Fill in: remove last

    dfs([], nums)
    return result
</code></pre>
<h2>Quiz 2: DFS Understanding</h2>
<p><strong>Answer the following questions:</strong></p>
<ol>
<li><strong>When should you use DFS over BFS?</strong></li>
</ol>
<p>Your answer:</p>
<hr />
<hr />
<ol>
<li><strong>What is the main difference between recursive and iterative DFS?</strong></li>
<li>[ ] Recursive uses a stack, iterative uses a queue</li>
<li>[ ] Recursive uses recursion stack, iterative uses explicit stack</li>
<li>[ ] They're completely different algorithms</li>
<li>[ ] Iterative is always better</li>
</ol>
<p>Your answer: <strong>______</strong></p>
<ol>
<li><strong>What is the time complexity of DFS?</strong></li>
<li>[ ] O(V)</li>
<li>[ ] O(E)</li>
<li>[ ] O(V + E)</li>
<li>[ ] O(V √ó E)</li>
</ol>
<p>Your answer: <strong>______</strong></p>
<ol>
<li><strong>When backtracking, what must you remember to do?</strong></li>
<li>[ ] Nothing special</li>
<li>[ ] Unmark as visited</li>
<li>[ ] Remove from path and unmark</li>
<li>[ ] Clear the entire path</li>
</ol>
<p>Your answer: <strong>______</strong></p>
<ol>
<li><strong>For tree traversal, which DFS order gives sorted order for BST?</strong></li>
<li>[ ] Preorder</li>
<li>[ ] Inorder</li>
<li>[ ] Postorder</li>
<li>[ ] Level-order</li>
</ol>
<p>Your answer: <strong>______</strong></p>
<ol>
<li><strong>What's the key difference between cycle detection in directed vs undirected graphs?</strong></li>
</ol>
<p>Your answer:</p>
<hr />
<ol>
<li><strong>Why do we reverse the result in topological sort?</strong></li>
</ol>
<p>Your answer:</p>
<hr />
<ol>
<li><strong>In DFS backtracking, why do we make a copy before adding to result?</strong></li>
<li>[ ] To save memory</li>
<li>[ ] Because lists are mutable and we'll backtrack</li>
<li>[ ] Because it's faster</li>
<li>[ ] It doesn't matter</li>
</ol>
<p>Your answer: <strong>______</strong></p>
<hr />
<h2>Quiz 3: DFS Advanced Concepts</h2>
<p><strong>Answer these advanced DFS questions:</strong></p>
<ol>
<li><strong>What are the three states used in cycle detection for directed graphs?</strong></li>
<li>[ ] Unvisited, Visiting, Visited</li>
<li>[ ] White, Gray, Black</li>
<li>[ ] 0, 1, 2</li>
<li>[ ] All of the above</li>
</ol>
<p>Your answer: <strong>______</strong></p>
<ol>
<li><strong>Why does topological sort use postorder traversal?</strong></li>
</ol>
<p>Your answer:</p>
<hr />
<ol>
<li><strong>What happens if we mark visited nodes when popping from stack instead of pushing?</strong></li>
</ol>
<p>Your answer:</p>
<hr />
<ol>
<li><strong>When would you use iterative DFS instead of recursive DFS?</strong></li>
</ol>
<p>Your answer:</p>
<hr />
<hr />
<h1>Part 5: Comparison &amp; Decision Making</h1>
<h2>Exercise 10: Choose BFS or DFS</h2>
<p><strong>For each problem, choose BFS or DFS and explain why:</strong></p>
<ol>
<li><strong>Finding shortest path in unweighted graph</strong></li>
<li>[ ] BFS</li>
<li>[ ] DFS</li>
</ol>
<p>Why: <strong><em>_</em></strong><strong><em>_</em></strong><strong><em>_</em></strong><strong><em>_</em></strong><strong><em>_</em></strong><strong><em>_</em></strong><strong><em>_</em></strong><strong><em>_</em></strong><strong><em>_</em></strong><strong><em>_</em></strong>_</p>
<ol>
<li><strong>Finding all permutations of a string</strong></li>
<li>[ ] BFS</li>
<li>[ ] DFS</li>
</ol>
<p>Why: <strong><em>_</em></strong><strong><em>_</em></strong><strong><em>_</em></strong><strong><em>_</em></strong><strong><em>_</em></strong><strong><em>_</em></strong><strong><em>_</em></strong><strong><em>_</em></strong><strong><em>_</em></strong><strong><em>_</em></strong>_</p>
<ol>
<li><strong>Counting connected components in a graph</strong></li>
<li>[ ] BFS</li>
<li>[ ] DFS</li>
</ol>
<p>Why: <strong><em>_</em></strong><strong><em>_</em></strong><strong><em>_</em></strong><strong><em>_</em></strong><strong><em>_</em></strong><strong><em>_</em></strong><strong><em>_</em></strong><strong><em>_</em></strong><strong><em>_</em></strong><strong><em>_</em></strong>_</p>
<ol>
<li><strong>Finding level-order traversal of a tree</strong></li>
<li>[ ] BFS</li>
<li>[ ] DFS</li>
</ol>
<p>Why: <strong><em>_</em></strong><strong><em>_</em></strong><strong><em>_</em></strong><strong><em>_</em></strong><strong><em>_</em></strong><strong><em>_</em></strong><strong><em>_</em></strong><strong><em>_</em></strong><strong><em>_</em></strong><strong><em>_</em></strong>_</p>
<ol>
<li><strong>Detecting cycles in a directed graph</strong></li>
<li>[ ] BFS</li>
<li>[ ] DFS</li>
</ol>
<p>Why: <strong><em>_</em></strong><strong><em>_</em></strong><strong><em>_</em></strong><strong><em>_</em></strong><strong><em>_</em></strong><strong><em>_</em></strong><strong><em>_</em></strong><strong><em>_</em></strong><strong><em>_</em></strong><strong><em>_</em></strong>_</p>
<h2>Exercise 11: Problem Recognition</h2>
<p><strong>Circle the keywords that indicate BFS or DFS:</strong></p>
<ol>
<li>"Find the minimum number of steps"</li>
<li>
<p>BFS / DFS</p>
</li>
<li>
<p>"Generate all possible combinations"</p>
</li>
<li>
<p>BFS / DFS</p>
</li>
<li>
<p>"Count the number of islands"</p>
</li>
<li>
<p>BFS / DFS</p>
</li>
<li>
<p>"Print tree level by level"</p>
</li>
<li>
<p>BFS / DFS</p>
</li>
<li>
<p>"Find if a path exists (any path)"</p>
</li>
<li>BFS / DFS</li>
</ol>
<hr />
<h1>Part 6: Practice Problems</h1>
<h2>Problem 1: Number of Islands (BFS or DFS)</h2>
<p><strong>Given a 2D grid of '1's (land) and '0's (water), count the number of islands.</strong></p>
<p><strong>Your solution:</strong></p>
<pre><code class="language-python">def num_islands(grid: List[List[str]]) -&gt; int:
    &quot;&quot;&quot;
    TODO: Implement using BFS or DFS
    &quot;&quot;&quot;
    # Your code here:











</code></pre>
<p><strong>Which approach did you choose?</strong> <strong>______</strong> (BFS/DFS)</p>
<p><strong>Why?</strong> <strong><em>_</em></strong><strong><em>_</em></strong><strong><em>_</em></strong><strong><em>_</em></strong><strong><em>_</em></strong><strong><em>_</em></strong><strong><em>_</em></strong><strong><em>_</em></strong><strong><em>_</em></strong><strong><em>_</em></strong>_</p>
<h2>Problem 2: Word Ladder (BFS)</h2>
<p><strong>Given two words and a dictionary, find the shortest transformation sequence.</strong></p>
<p><strong>Your solution:</strong></p>
<pre><code class="language-python">def word_ladder(begin_word: str, end_word: str, word_list: List[str]) -&gt; int:
    &quot;&quot;&quot;
    TODO: Implement using BFS
    &quot;&quot;&quot;
    # Your code here:











</code></pre>
<h2>Problem 3: Binary Tree Maximum Depth (DFS)</h2>
<p><strong>Find the maximum depth of a binary tree.</strong></p>
<p><strong>Your solution:</strong></p>
<pre><code class="language-python">def max_depth(root: Optional[TreeNode]) -&gt; int:
    &quot;&quot;&quot;
    TODO: Implement using DFS (recursive or iterative)
    &quot;&quot;&quot;
    # Your code here:











</code></pre>
<h2>Problem 4: Course Schedule (DFS)</h2>
<p><strong>Check if you can finish all courses given prerequisites (cycle detection).</strong></p>
<p><strong>Your solution:</strong></p>
<pre><code class="language-python">def can_finish(num_courses: int, prerequisites: List[List[int]]) -&gt; bool:
    &quot;&quot;&quot;
    TODO: Implement using DFS for cycle detection
    &quot;&quot;&quot;
    # Your code here:











</code></pre>
<h2>Problem 5: Maximum Depth of Binary Tree (DFS)</h2>
<p><strong>Find the maximum depth of a binary tree using DFS.</strong></p>
<p><strong>Your solution:</strong></p>
<pre><code class="language-python">def max_depth(root: Optional[TreeNode]) -&gt; int:
    &quot;&quot;&quot;
    TODO: Implement using DFS (recursive or iterative)
    &quot;&quot;&quot;
    # Your code here:











</code></pre>
<h2>Problem 6: Same Tree (DFS)</h2>
<p><strong>Check if two binary trees are the same.</strong></p>
<p><strong>Your solution:</strong></p>
<pre><code class="language-python">def is_same_tree(p: Optional[TreeNode], q: Optional[TreeNode]) -&gt; bool:
    &quot;&quot;&quot;
    TODO: Implement using DFS
    &quot;&quot;&quot;
    # Your code here:











</code></pre>
<h2>Problem 7: Invert Binary Tree (DFS)</h2>
<p><strong>Invert a binary tree (swap left and right children for every node).</strong></p>
<p><strong>Your solution:</strong></p>
<pre><code class="language-python">def invert_tree(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:
    &quot;&quot;&quot;
    TODO: Implement using DFS
    &quot;&quot;&quot;
    # Your code here:











</code></pre>
<h2>Problem 8: Path Sum (DFS)</h2>
<p><strong>Check if there exists a root-to-leaf path with sum equal to target.</strong></p>
<p><strong>Your solution:</strong></p>
<pre><code class="language-python">def has_path_sum(root: Optional[TreeNode], target_sum: int) -&gt; bool:
    &quot;&quot;&quot;
    TODO: Implement using DFS
    &quot;&quot;&quot;
    # Your code here:











</code></pre>
<h2>Problem 9: Validate Binary Search Tree (DFS)</h2>
<p><strong>Check if a binary tree is a valid BST.</strong></p>
<p><strong>Your solution:</strong></p>
<pre><code class="language-python">def is_valid_bst(root: Optional[TreeNode]) -&gt; bool:
    &quot;&quot;&quot;
    TODO: Implement using DFS inorder traversal
    &quot;&quot;&quot;
    # Your code here:











</code></pre>
<h2>Problem 10: Symmetric Tree (DFS)</h2>
<p><strong>Check if a binary tree is symmetric (mirror of itself).</strong></p>
<p><strong>Your solution:</strong></p>
<pre><code class="language-python">def is_symmetric(root: Optional[TreeNode]) -&gt; bool:
    &quot;&quot;&quot;
    TODO: Implement using DFS
    &quot;&quot;&quot;
    # Your code here:











</code></pre>
<hr />
<h1>Part 6: DFS Solved Problems - Learn from Solutions</h1>
<h2>Solved Problem 1: Number of Islands (DFS)</h2>
<p><strong>Problem:</strong> Given a 2D grid of '1's (land) and '0's (water), count the number of islands.</p>
<p><strong>Solution:</strong></p>
<pre><code class="language-python">def num_islands(grid: List[List[str]]) -&gt; int:
    &quot;&quot;&quot;
    Count islands using DFS flood fill.

    Strategy:
    1. Iterate through grid
    2. When we find '1', it's a new island
    3. Use DFS to mark all connected '1's as visited (sink them)
    4. Count total islands

    Time: O(m √ó n) where m, n are grid dimensions
    Space: O(m √ó n) for recursion stack (worst case: entire grid is land)
    &quot;&quot;&quot;
    if not grid:
        return 0

    rows, cols = len(grid), len(grid[0])
    count = 0

    def dfs(r, c):
        # Base case: out of bounds or water
        if (r &lt; 0 or r &gt;= rows or 
            c &lt; 0 or c &gt;= cols or
            grid[r][c] != '1'):
            return

        # Mark as visited (sink the island)
        grid[r][c] = '0'

        # Explore all 4 directions
        dfs(r - 1, c)  # up
        dfs(r + 1, c)  # down
        dfs(r, c - 1)  # left
        dfs(r, c + 1)  # right

    # Find all islands
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == '1':
                count += 1
                dfs(r, c)  # Sink entire island

    return count

# Example:
# grid = [
#   [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],
#   [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],
#   [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],
#   [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]
# ]
# Result: 1 island
</code></pre>
<p><strong>Key Points:</strong>
- Use DFS to "sink" (mark as visited) all connected land cells
- Each DFS call from a '1' cell represents one island
- Mark visited by changing '1' to '0' (or use visited set)</p>
<h2>Solved Problem 2: Word Search (DFS Backtracking)</h2>
<p><strong>Problem:</strong> Given a 2D board and a word, find if the word exists by moving adjacent.</p>
<p><strong>Solution:</strong></p>
<pre><code class="language-python">def exist(board: List[List[str]], word: str) -&gt; bool:
    &quot;&quot;&quot;
    Word search using DFS backtracking.

    Strategy:
    1. Try starting from each cell
    2. Use DFS to explore paths
    3. Mark visited cells temporarily (backtrack)
    4. If word found, return True

    Time: O(m √ó n √ó 4^L) where L is word length
    Space: O(L) for recursion stack
    &quot;&quot;&quot;
    rows, cols = len(board), len(board[0])

    def dfs(r, c, index):
        # Base case: found entire word
        if index == len(word):
            return True

        # Out of bounds or doesn't match
        if (r &lt; 0 or r &gt;= rows or 
            c &lt; 0 or c &gt;= cols or
            board[r][c] != word[index]):
            return False

        # Mark as visited temporarily (use special char)
        temp = board[r][c]
        board[r][c] = '#'  # Mark visited

        # Explore 4 directions
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        found = False
        for dr, dc in directions:
            if dfs(r + dr, c + dc, index + 1):
                found = True
                break

        # Backtrack: restore original value
        board[r][c] = temp
        return found

    # Try starting from each cell
    for r in range(rows):
        for c in range(cols):
            if dfs(r, c, 0):
                return True

    return False

# Example:
# board = [
#   [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],
#   [&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],
#   [&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]
# ]
# word = &quot;ABCCED&quot;
# Result: True (path: A‚ÜíB‚ÜíC‚ÜíC‚ÜíE‚ÜíD)
</code></pre>
<p><strong>Key Points:</strong>
- Must backtrack: restore cell value after exploring
- Use temporary marker ('#') to prevent revisiting in current path
- Try starting from every cell</p>
<h2>Solved Problem 3: Generate Parentheses (DFS Backtracking)</h2>
<p><strong>Problem:</strong> Generate all combinations of n pairs of valid parentheses.</p>
<p><strong>Solution:</strong></p>
<pre><code class="language-python">def generate_parenthesis(n: int) -&gt; List[str]:
    &quot;&quot;&quot;
    Generate valid parentheses using DFS backtracking.

    Strategy:
    1. Track open_count and close_count
    2. Can add '(' if open_count &lt; n
    3. Can add ')' if close_count &lt; open_count
    4. When length = 2*n, add to result

    Time: O(4^n / sqrt(n)) - Catalan number
    Space: O(4^n / sqrt(n)) for result + O(n) for recursion
    &quot;&quot;&quot;
    result = []

    def dfs(open_count, close_count, current):
        # Base case: valid combination found
        if len(current) == 2 * n:
            result.append(current)
            return

        # Can add opening parenthesis
        if open_count &lt; n:
            dfs(open_count + 1, close_count, current + '(')

        # Can add closing parenthesis (must have more opens)
        if close_count &lt; open_count:
            dfs(open_count, close_count + 1, current + ')')

    dfs(0, 0, &quot;&quot;)
    return result

# Example: n = 3
# Result: [&quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;]
</code></pre>
<p><strong>Key Points:</strong>
- Two constraints: open_count ‚â§ n, close_count ‚â§ open_count
- Track counts, not just string length
- When both counts = n, we have valid combination</p>
<h2>Solved Problem 4: Course Schedule (DFS Cycle Detection)</h2>
<p><strong>Problem:</strong> Check if you can finish all courses given prerequisites (no cycles).</p>
<p><strong>Solution:</strong></p>
<pre><code class="language-python">def can_finish(num_courses: int, prerequisites: List[List[int]]) -&gt; bool:
    &quot;&quot;&quot;
    Check for cycles using DFS with color states.

    Strategy:
    1. Build graph: course ‚Üí list of prerequisites
    2. Use DFS with 3 states: WHITE(0), GRAY(1), BLACK(2)
    3. GRAY = in current path, BLACK = processed
    4. If we find GRAY node, cycle detected!

    Time: O(V + E)
    Space: O(V + E) for graph + recursion
    &quot;&quot;&quot;
    # Build graph: course ‚Üí [prerequisites]
    graph = {i: [] for i in range(num_courses)}
    for course, prereq in prerequisites:
        graph[course].append(prereq)

    # 0 = WHITE (unvisited), 1 = GRAY (visiting), 2 = BLACK (done)
    color = {i: 0 for i in range(num_courses)}

    def dfs(course):
        if color[course] == 1:  # GRAY = cycle!
            return True
        if color[course] == 2:  # BLACK = already processed
            return False

        # Mark as GRAY (in current path)
        color[course] = 1

        # Check prerequisites
        for prereq in graph[course]:
            if dfs(prereq):  # Cycle found
                return True

        # Mark as BLACK (finished)
        color[course] = 2
        return False

    # Check all courses
    for course in range(num_courses):
        if color[course] == 0:
            if dfs(course):
                return False  # Cycle found = can't finish

    return True  # No cycles = can finish

# Example:
# num_courses = 2
# prerequisites = [[1,0]]
# Result: True (0 ‚Üí 1, no cycle)
#
# prerequisites = [[1,0], [0,1]]
# Result: False (0 ‚Üí 1 ‚Üí 0, cycle!)
</code></pre>
<p><strong>Key Points:</strong>
- Three color states for cycle detection in directed graphs
- GRAY = in current recursion path (back edge = cycle!)
- BLACK = completely processed (skip in future)</p>
<h2>Solved Problem 5: Maximum Depth of Binary Tree (DFS)</h2>
<p><strong>Problem:</strong> Find maximum depth of binary tree.</p>
<p><strong>Solution:</strong></p>
<pre><code class="language-python">def max_depth(root: Optional[TreeNode]) -&gt; int:
    &quot;&quot;&quot;
    Maximum depth using DFS postorder.

    Strategy:
    1. If None, depth = 0
    2. Calculate depth of left subtree
    3. Calculate depth of right subtree
    4. Return 1 + max(left_depth, right_depth)

    Why postorder? Need children's depths before calculating parent's!

    Time: O(n) - visit each node once
    Space: O(h) - recursion stack, h = height
    &quot;&quot;&quot;
    if not root:
        return 0

    # Postorder: process children first
    left_depth = max_depth(root.left)
    right_depth = max_depth(root.right)

    # Process root: 1 (current) + max of children
    return 1 + max(left_depth, right_depth)

# Example:
#     3
#    / \
#   9  20
#     /  \
#    15   7
# Result: 3
</code></pre>
<p><strong>Key Points:</strong>
- Use postorder: need children's depths first
- Base case: None node has depth 0
- Return 1 + max(left, right)</p>
<h2>Solved Problem 6: Same Tree (DFS)</h2>
<p><strong>Problem:</strong> Check if two binary trees are identical.</p>
<p><strong>Solution:</strong></p>
<pre><code class="language-python">def is_same_tree(p: Optional[TreeNode], q: Optional[TreeNode]) -&gt; bool:
    &quot;&quot;&quot;
    Check if trees are same using DFS.

    Strategy:
    1. Both None? ‚Üí Same
    2. One None? ‚Üí Different
    3. Values different? ‚Üí Different
    4. Recursively check left and right subtrees

    Time: O(min(m, n)) where m, n are number of nodes
    Space: O(min(m, n)) for recursion
    &quot;&quot;&quot;
    # Both None
    if not p and not q:
        return True

    # One is None
    if not p or not q:
        return False

    # Values different
    if p.val != q.val:
        return False

    # Recursively check subtrees
    return (is_same_tree(p.left, q.left) and 
            is_same_tree(p.right, q.right))
</code></pre>
<p><strong>Key Points:</strong>
- Handle None cases first
- Check value equality
- Recursively check both subtrees</p>
<h2>Solved Problem 7: Validate Binary Search Tree (DFS Inorder)</h2>
<p><strong>Problem:</strong> Check if binary tree is valid BST.</p>
<p><strong>Solution:</strong></p>
<pre><code class="language-python">def is_valid_bst(root: Optional[TreeNode]) -&gt; bool:
    &quot;&quot;&quot;
    Validate BST using DFS inorder traversal.

    Strategy:
    Inorder traversal of BST gives sorted order!
    If inorder traversal is not strictly increasing ‚Üí not BST

    Time: O(n)
    Space: O(h) for recursion
    &quot;&quot;&quot;
    prev = None

    def inorder(node):
        nonlocal prev
        if not node:
            return True

        # Traverse left
        if not inorder(node.left):
            return False

        # Process root: check if value &gt; previous
        if prev is not None and node.val &lt;= prev:
            return False
        prev = node.val

        # Traverse right
        return inorder(node.right)

    return inorder(root)

# Alternative: Pass min/max bounds
def is_valid_bst_bounds(root: Optional[TreeNode]) -&gt; bool:
    def dfs(node, min_val, max_val):
        if not node:
            return True

        # Check bounds
        if node.val &lt;= min_val or node.val &gt;= max_val:
            return False

        # Recursively check with updated bounds
        return (dfs(node.left, min_val, node.val) and
                dfs(node.right, node.val, max_val))

    return dfs(root, float('-inf'), float('inf'))
</code></pre>
<p><strong>Key Points:</strong>
- Inorder traversal gives sorted order for BST
- Can use min/max bounds approach too
- Must be strictly increasing (no duplicates allowed)</p>
<hr />
<h1>Part 5: Tree Algorithms Fundamentals</h1>
<h2>üå≥ Understanding Binary Trees</h2>
<p><strong>Fill in the blanks:</strong></p>
<ol>
<li>
<p>A binary tree is a tree data structure where each node has at most <strong>______</strong> children.</p>
</li>
<li>
<p>Tree terminology:</p>
</li>
<li><strong>Root:</strong> The <strong>______</strong> node (has no parent)</li>
<li><strong>Leaf:</strong> Node with <strong>______</strong> children</li>
<li><strong>Depth:</strong> Number of edges from <strong>______</strong> to node</li>
<li><strong>Height:</strong> Maximum <strong>______</strong> in the tree</li>
<li>
<p><strong>Level:</strong> <strong>______</strong> + 1 (root is level 1)</p>
</li>
<li>
<p>Tree properties:</p>
</li>
<li><strong>Full Binary Tree:</strong> Every node has <strong>______</strong> or <strong>______</strong> children</li>
<li><strong>Complete Binary Tree:</strong> All levels filled except possibly last, filled <strong>______</strong></li>
<li><strong>Perfect Binary Tree:</strong> All levels are <strong>______</strong> filled</li>
<li><strong>Balanced Binary Tree:</strong> Height difference between subtrees ‚â§ <strong>______</strong></li>
</ol>
<h2>üìä Tree Representation</h2>
<p><strong>Complete the code:</strong></p>
<pre><code class="language-python">class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = ________________  # Fill in
        self.right = ________________  # Fill in
</code></pre>
<hr />
<h1>Part 6: Tree Traversal Techniques (BFS &amp; DFS)</h1>
<h2>Exercise 17: Binary Tree Level Order (BFS) - Complete the Code</h2>
<pre><code class="language-python">def level_order(root: Optional[TreeNode]) -&gt; List[List[int]]:
    &quot;&quot;&quot;
    Level-order traversal using BFS (each level as separate list).

    TODO: Complete the BFS level-order traversal
    &quot;&quot;&quot;
    if not root:
        return []

    result = []
    queue = deque([root])

    while queue:
        level_size = ________________  # Fill in: nodes at current level
        current_level = []

        # Process all nodes at current level
        for _ in range(level_size):
            node = queue.________________  # Fill in: remove from queue
            current_level.append(node.val)

            # Add children to queue (next level)
            if node.left:
                queue.________________  # Fill in
            if node.right:
                queue.________________  # Fill in

        result.append(current_level)

    return result
</code></pre>
<h2>Exercise 18: Binary Tree Zigzag Level Order (BFS) - Complete the Code</h2>
<pre><code class="language-python">def zigzag_level_order(root: Optional[TreeNode]) -&gt; List[List[int]]:
    &quot;&quot;&quot;
    Zigzag level-order: alternate left-to-right and right-to-left.

    TODO: Complete the zigzag traversal
    &quot;&quot;&quot;
    if not root:
        return []

    result = []
    queue = deque([root])
    left_to_right = True

    while queue:
        level_size = len(queue)
        current_level = []

        for _ in range(level_size):
            node = queue.popleft()

            if left_to_right:
                current_level.________________  # Fill in: append
            else:
                current_level.________________  # Fill in: insert at start

            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)

        result.append(current_level)
        left_to_right = ________________  # Fill in: toggle direction

    return result
</code></pre>
<h2>Exercise 19: Binary Tree Right Side View (BFS) - Complete the Code</h2>
<pre><code class="language-python">def right_side_view(root: Optional[TreeNode]) -&gt; List[int]:
    &quot;&quot;&quot;
    Return values of nodes visible from right side.

    TODO: Complete the right side view using BFS
    &quot;&quot;&quot;
    if not root:
        return []

    result = []
    queue = deque([root])

    while queue:
        level_size = len(queue)

        for i in range(level_size):
            node = queue.popleft()

            # Rightmost node at this level
            if i == ________________:  # Fill in: last node condition
                result.append(node.val)

            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)

    return result
</code></pre>
<h2>Exercise 20: Binary Tree Maximum Depth (DFS Postorder) - Complete the Code</h2>
<pre><code class="language-python">def max_depth(root: Optional[TreeNode]) -&gt; int:
    &quot;&quot;&quot;
    Maximum depth using DFS postorder.

    TODO: Complete the depth calculation
    &quot;&quot;&quot;
    if not root:
        return ________________  # Fill in: base case

    # Postorder: process children first
    left_depth = max_depth(________________)  # Fill in
    right_depth = max_depth(________________)  # Fill in

    # Process root: 1 (current) + max of children
    return ________________ + ________________(left_depth, right_depth)  # Fill in
</code></pre>
<h2>Exercise 21: Binary Tree Minimum Depth (BFS) - Complete the Code</h2>
<pre><code class="language-python">def min_depth(root: Optional[TreeNode]) -&gt; int:
    &quot;&quot;&quot;
    Minimum depth using BFS (shortest path to leaf).

    TODO: Complete the BFS minimum depth
    &quot;&quot;&quot;
    if not root:
        return 0

    queue = deque([(root, 1)])  # (node, depth)

    while queue:
        node, depth = queue.________________  # Fill in

        # Found a leaf (minimum depth)
        if not node.left and not node.right:
            return ________________  # Fill in

        if node.left:
            queue.append((________________, ________________))  # Fill in
        if node.right:
            queue.append((________________, ________________))  # Fill in

    return 0
</code></pre>
<h2>Exercise 22: Invert Binary Tree (DFS) - Complete the Code</h2>
<pre><code class="language-python">def invert_tree(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:
    &quot;&quot;&quot;
    Invert binary tree (swap left and right children).

    TODO: Complete the inversion using DFS
    &quot;&quot;&quot;
    if not root:
        return None

    # Swap children
    root.left, root.right = ________________, ________________  # Fill in

    # Recursively invert subtrees
    invert_tree(root.left)
    invert_tree(root.right)

    return root
</code></pre>
<h2>Exercise 23: Same Tree (DFS) - Complete the Code</h2>
<pre><code class="language-python">def is_same_tree(p: Optional[TreeNode], q: Optional[TreeNode]) -&gt; bool:
    &quot;&quot;&quot;
    Check if two trees are identical.

    TODO: Complete the comparison logic
    &quot;&quot;&quot;
    # Both None
    if ________________:  # Fill in: both None condition
        return True

    # One is None
    if ________________ or ________________:  # Fill in: one None condition
        return False

    # Values different
    if p.val != q.val:
        return False

    # Recursively check subtrees
    return (is_same_tree(________________, ________________) and  # Fill in
            is_same_tree(________________, ________________))  # Fill in
</code></pre>
<h2>Exercise 24: Symmetric Tree (DFS) - Complete the Code</h2>
<pre><code class="language-python">def is_symmetric(root: Optional[TreeNode]) -&gt; bool:
    &quot;&quot;&quot;
    Check if tree is symmetric (mirror of itself).

    TODO: Complete the symmetric check
    &quot;&quot;&quot;
    if not root:
        return True

    def is_mirror(left, right):
        # Both None
        if not left and not right:
            return True

        # One is None
        if not left or not right:
            return False

        # Values must match and subtrees must be mirror
        return (left.val == right.val and
                is_mirror(left.left, ________________) and  # Fill in
                is_mirror(left.right, ________________))  # Fill in

    return is_mirror(________________, ________________)  # Fill in
</code></pre>
<hr />
<h1>Part 7: Tree Problem Patterns</h1>
<h2>Exercise 25: Path Sum (DFS) - Complete the Code</h2>
<pre><code class="language-python">def has_path_sum(root: Optional[TreeNode], target_sum: int) -&gt; bool:
    &quot;&quot;&quot;
    Check if there exists a root-to-leaf path with sum equal to target.

    TODO: Complete the path sum check
    &quot;&quot;&quot;
    if not root:
        return False

    # Leaf node: check if sum matches
    if not root.left and not root.right:
        return target_sum == ________________  # Fill in

    # Recursively check left and right subtrees
    remaining = target_sum - ________________  # Fill in: subtract current value
    return (has_path_sum(root.left, ________________) or  # Fill in
            has_path_sum(root.right, ________________))  # Fill in
</code></pre>
<h2>Exercise 26: All Paths from Root to Leaves (DFS Backtracking) - Complete the Code</h2>
<pre><code class="language-python">def binary_tree_paths(root: Optional[TreeNode]) -&gt; List[str]:
    &quot;&quot;&quot;
    Return all root-to-leaf paths.

    Example: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]

    TODO: Complete the path collection
    &quot;&quot;&quot;
    result = []

    def dfs(node, path):
        if not node:
            return

        # Add current node to path
        path.append(str(node.val))

        # Leaf node: add path to result
        if not node.left and not node.right:
            result.append(&quot;-&gt;&quot;.join(________________))  # Fill in
        else:
            # Continue DFS
            dfs(node.left, path)
            dfs(node.right, path)

        # Backtrack: remove current node
        path.________________  # Fill in

    dfs(root, [])
    return result
</code></pre>
<h2>Exercise 27: Path Sum II (DFS Backtracking) - Complete the Code</h2>
<pre><code class="language-python">def path_sum(root: Optional[TreeNode], target_sum: int) -&gt; List[List[int]]:
    &quot;&quot;&quot;
    Return all root-to-leaf paths where sum equals target.

    TODO: Complete the backtracking logic
    &quot;&quot;&quot;
    result = []

    def dfs(node, remaining, path):
        if not node:
            return

        # Add current node
        path.append(node.val)
        remaining -= node.val

        # Leaf node: check if sum matches
        if not node.left and not node.right and remaining == 0:
            result.append(________________)  # Fill in: add copy of path

        # Continue DFS
        dfs(node.left, remaining, path)
        dfs(node.right, remaining, path)

        # Backtrack
        path.________________  # Fill in

    dfs(root, target_sum, [])
    return result
</code></pre>
<h2>Exercise 28: Lowest Common Ancestor (DFS) - Complete the Code</h2>
<pre><code class="language-python">def lowest_common_ancestor(root: TreeNode, p: TreeNode, q: TreeNode) -&gt; TreeNode:
    &quot;&quot;&quot;
    Find lowest common ancestor of two nodes.

    Strategy:
    - If both nodes in left subtree ‚Üí LCA in left
    - If both nodes in right subtree ‚Üí LCA in right
    - Otherwise, root is LCA

    TODO: Complete the LCA logic
    &quot;&quot;&quot;
    if not root or root == p or root == q:
        return ________________  # Fill in

    left = lowest_common_ancestor(root.left, p, q)
    right = lowest_common_ancestor(root.right, p, q)

    # Both found in different subtrees ‚Üí root is LCA
    if left and right:
        return ________________  # Fill in

    # Both in same subtree
    return ________________ or ________________  # Fill in: left or right
</code></pre>
<h2>Exercise 29: Construct Binary Tree from Preorder and Inorder (DFS) - Complete the Code</h2>
<pre><code class="language-python">def build_tree(preorder: List[int], inorder: List[int]) -&gt; Optional[TreeNode]:
    &quot;&quot;&quot;
    Build tree from preorder and inorder traversals.

    Strategy:
    1. Preorder[0] is root
    2. Find root in inorder ‚Üí split into left and right subtrees
    3. Recursively build subtrees

    TODO: Complete the tree construction
    &quot;&quot;&quot;
    if not preorder or not inorder:
        return None

    # Root is first in preorder
    root_val = preorder[0]
    root = TreeNode(root_val)

    # Find root in inorder
    root_index = inorder.index(________________)  # Fill in

    # Split inorder into left and right subtrees
    left_inorder = inorder[:root_index]
    right_inorder = inorder[root_index + 1:]

    # Split preorder (skip root)
    left_preorder = preorder[1:1 + len(left_inorder)]
    right_preorder = preorder[1 + len(left_inorder):]

    # Recursively build subtrees
    root.left = build_tree(________________, ________________)  # Fill in
    root.right = build_tree(________________, ________________)  # Fill in

    return root
</code></pre>
<h2>Exercise 30: Serialize and Deserialize Binary Tree (DFS Preorder) - Complete the Code</h2>
<pre><code class="language-python">def serialize(root: Optional[TreeNode]) -&gt; str:
    &quot;&quot;&quot;
    Serialize tree to string using DFS preorder.

    TODO: Complete the serialization
    &quot;&quot;&quot;
    result = []

    def dfs(node):
        if not node:
            result.append(&quot;null&quot;)
        else:
            result.append(str(node.val))
            dfs(node.left)
            dfs(node.right)

    dfs(root)
    return &quot;,&quot;.join(result)

def deserialize(data: str) -&gt; Optional[TreeNode]:
    &quot;&quot;&quot;
    Deserialize string to tree.

    TODO: Complete the deserialization
    &quot;&quot;&quot;
    values = data.split(&quot;,&quot;)
    index = 0

    def dfs():
        nonlocal index
        if index &gt;= len(values) or values[index] == &quot;null&quot;:
            index += 1
            return None

        root = TreeNode(int(values[index]))
        index += 1
        root.left = dfs()
        root.right = dfs()
        return root

    return dfs()
</code></pre>
<hr />
<h1>Part 8: Advanced Tree Algorithms</h1>
<h2>Exercise 31: Validate Binary Search Tree (DFS Inorder) - Complete the Code</h2>
<pre><code class="language-python">def is_valid_bst(root: Optional[TreeNode]) -&gt; bool:
    &quot;&quot;&quot;
    Validate BST using inorder traversal.

    Strategy: Inorder traversal of BST gives sorted order!

    TODO: Complete the validation
    &quot;&quot;&quot;
    prev = None

    def inorder(node):
        nonlocal prev
        if not node:
            return True

        # Traverse left
        if not inorder(node.left):
            return False

        # Process root: check if value &gt; previous
        if prev is not None and node.val &lt;= prev:
            return ________________  # Fill in
        prev = node.val

        # Traverse right
        return inorder(node.right)

    return inorder(root)
</code></pre>
<h2>Exercise 32: Kth Smallest Element in BST (DFS Inorder) - Complete the Code</h2>
<pre><code class="language-python">def kth_smallest(root: Optional[TreeNode], k: int) -&gt; int:
    &quot;&quot;&quot;
    Find kth smallest element in BST.

    Strategy: Inorder traversal gives sorted order ‚Üí kth element = answer

    TODO: Complete the kth smallest search
    &quot;&quot;&quot;
    count = 0
    result = None

    def inorder(node):
        nonlocal count, result
        if not node:
            return

        inorder(node.left)

        count += 1
        if count == ________________:  # Fill in: kth element
            result = node.val
            return

        inorder(node.right)

    inorder(root)
    return result
</code></pre>
<h2>Exercise 33: Count Complete Tree Nodes (DFS with Optimization) - Complete the Code</h2>
<pre><code class="language-python">def count_nodes(root: Optional[TreeNode]) -&gt; int:
    &quot;&quot;&quot;
    Count nodes in complete binary tree efficiently.

    Strategy: Check if left and right heights are equal

    TODO: Complete the optimized count
    &quot;&quot;&quot;
    if not root:
        return 0

    # Calculate left and right heights
    left_height = 0
    right_height = 0

    node = root.left
    while node:
        left_height += 1
        node = node.left

    node = root.right
    while node:
        right_height += 1
        node = node.right

    # If heights equal, tree is perfect (use formula)
    if left_height == right_height:
        return (2 ** (left_height + 1)) - 1  # 2^height - 1

    # Otherwise, recursively count
    return 1 + count_nodes(________________) + count_nodes(________________)  # Fill in
</code></pre>
<h2>Exercise 34: Binary Tree Maximum Path Sum (DFS) - Complete the Code</h2>
<pre><code class="language-python">def max_path_sum(root: Optional[TreeNode]) -&gt; int:
    &quot;&quot;&quot;
    Find maximum path sum (path can start and end anywhere).

    Strategy:
    - For each node, calculate max path through it
    - Path can go through node: node.val + left_max + right_max
    - Return max contribution from subtree: node.val + max(left, right)

    TODO: Complete the max path sum
    &quot;&quot;&quot;
    max_sum = float('-inf')

    def dfs(node):
        nonlocal max_sum
        if not node:
            return 0

        # Max contributions from left and right subtrees (can be negative)
        left_max = max(0, dfs(node.left))
        right_max = max(0, dfs(node.right))

        # Max path through current node
        current_max = node.val + left_max + right_max
        max_sum = max(max_sum, ________________)  # Fill in

        # Return max contribution from this subtree
        return node.val + max(________________, ________________)  # Fill in

    dfs(root)
    return max_sum
</code></pre>
<h2>Exercise 35: Diameter of Binary Tree (DFS Postorder) - Complete the Code</h2>
<pre><code class="language-python">def diameter_of_binary_tree(root: Optional[TreeNode]) -&gt; int:
    &quot;&quot;&quot;
    Find diameter (longest path between any two nodes).

    Strategy: Diameter = max(left_height + right_height + 1) for all nodes

    TODO: Complete the diameter calculation
    &quot;&quot;&quot;
    max_diameter = 0

    def dfs(node):
        nonlocal max_diameter
        if not node:
            return 0

        # Get heights of subtrees
        left_height = dfs(node.left)
        right_height = dfs(node.right)

        # Update diameter (path through current node)
        max_diameter = max(max_diameter, ________________)  # Fill in

        # Return height of subtree
        return 1 + max(________________, ________________)  # Fill in

    dfs(root)
    return max_diameter
</code></pre>
<hr />
<h1>Part 9: Comparison &amp; Decision Making</h1>
<h2>BFS Core Concepts Answers</h2>
<ol>
<li>1, 2, 3</li>
<li>level by level, distance</li>
<li>shortest</li>
<li>queue</li>
<li>level by level</li>
</ol>
<h2>BFS Algorithm Steps Answers</h2>
<ol>
<li>queue, visited set, start</li>
<li>not empty, dequeue/popleft, process, neighbor, not, mark, queue</li>
<li>before</li>
</ol>
<h2>BFS vs DFS Comparison Answers</h2>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>BFS</th>
<th>DFS</th>
</tr>
</thead>
<tbody>
<tr>
<td>Data Structure</td>
<td>Queue</td>
<td>Stack</td>
</tr>
<tr>
<td>Exploration Order</td>
<td>Level by level</td>
<td>As deep as possible</td>
</tr>
<tr>
<td>Finds</td>
<td>Shortest path</td>
<td>A path</td>
</tr>
<tr>
<td>Memory Usage</td>
<td>More (stores level)</td>
<td>Less (stores path)</td>
</tr>
<tr>
<td>Good For</td>
<td>Shortest path, level-order</td>
<td>Backtracking, all paths</td>
</tr>
</tbody>
</table>
<h2>Exercise 1 Answers</h2>
<pre><code class="language-python">queue = deque([start])
while queue:
    node = queue.popleft()
    if neighbor not in visited:
        visited.add(neighbor)
        queue.append(neighbor)
</code></pre>
<h2>Exercise 2 Answers</h2>
<pre><code class="language-python">node = queue.popleft()
if neighbor not in levels:
    levels[neighbor] = current_level + 1
    queue.append(neighbor)
</code></pre>
<h2>Exercise 3 Answers</h2>
<pre><code class="language-python">r, c, dist = queue.popleft()
return dist
nr, nc = r + dr, c + dc
if (nr, nc) not in visited:
    queue.append((nr, nc, dist + 1))
</code></pre>
<h2>Exercise 4 Answers</h2>
<pre><code class="language-python">if neighbor not in visited:
    visited.add(neighbor)
    parent[neighbor] = current
    queue.append(neighbor)
    while node is not None:
        node = parent.get(node)
</code></pre>
<h2>Quiz 1 Answers</h2>
<ol>
<li>BFS explores level by level, so the first time we reach a node is via the shortest path.</li>
<li>Before adding to queue</li>
<li>O(V + E)</li>
<li>O(V)</li>
<li>A ‚Üí B ‚Üí C ‚Üí D ‚Üí E ‚Üí F</li>
</ol>
<h2>DFS Core Concepts Answers</h2>
<ol>
<li>deep, backtrack, deep</li>
<li>deep, backtracking</li>
<li>Exploring, Backtracking, Detecting, Topological</li>
<li>stack, recursion</li>
<li>current</li>
</ol>
<h2>DFS Algorithm Steps Answers</h2>
<p><strong>Recursive:</strong>
1. None, visited
2. Mark, process
3. neighbor, not, DFS</p>
<p><strong>Iterative:</strong>
1. stack, visited set, start
2. not empty, pop, not, mark, process, neighbors</p>
<h2>DFS Patterns Answers</h2>
<ol>
<li>B (BST gives sorted order)</li>
<li>A (Copy/serialize tree)</li>
<li>C (Delete tree/calculate size)</li>
</ol>
<h2>Exercise 5-9 Answers</h2>
<p><strong>Exercise 5:</strong></p>
<pre><code class="language-python">if node in visited:
    return
visited.add(node)
if neighbor not in visited:
    dfs_recursive(graph, neighbor, visited)
</code></pre>
<p><strong>Exercise 6:</strong></p>
<pre><code class="language-python">stack = [start]
while stack:
    node = stack.pop()
    if node not in visited:
        visited.add(node)
        if neighbor not in visited:
            stack.append(neighbor)
</code></pre>
<p><strong>Exercise 7:</strong></p>
<pre><code class="language-python">if (r, c) in visited or:
    return 0
count += dfs_grid(grid, r + dr, c + dc, visited)
</code></pre>
<p><strong>Exercise 8:</strong></p>
<pre><code class="language-python">return True
if neighbor not in visited:
    if dfs_with_path(graph, neighbor, end, path, visited):
        return True
path.pop()
</code></pre>
<p><strong>Exercise 9:</strong></p>
<pre><code class="language-python">dfs_backtrack(candidates, path, result)
path.pop()
</code></pre>
<h2>Exercise 10-16 Answers (New DFS Exercises)</h2>
<p><strong>Exercise 10: Cycle Detection</strong></p>
<pre><code class="language-python">if color[node] == 1:  # GRAY = cycle found!
    return True
if color[node] == 2:  # BLACK = already processed
    return False
color[node] = 1  # Mark as GRAY
if dfs(neighbor):
    return True
color[node] = 2  # Mark as BLACK
</code></pre>
<p><strong>Exercise 11: Topological Sort</strong></p>
<pre><code class="language-python">if node in visited:  # Already in result
    return
visited.add(node)
if neighbor not in visited:
    dfs(neighbor)
result.append(node)  # Postorder: add after exploring dependencies
</code></pre>
<p><strong>Exercise 12: Tree Traversals</strong></p>
<pre><code class="language-python"># Inorder: Left ‚Üí Root ‚Üí Right
inorder(node.left)
result.append(node.val)
inorder(node.right)

# Preorder: Root ‚Üí Left ‚Üí Right
result.append(node.val)
preorder(node.left)
preorder(node.right)

# Postorder: Left ‚Üí Right ‚Üí Root
postorder(node.left)
postorder(node.right)
result.append(node.val)
</code></pre>
<p><strong>Exercise 13: Generate Parentheses</strong></p>
<pre><code class="language-python">if len(current) == 2 * n:  # Target length
    result.append(current)
    return
if open_count &lt; n:
    dfs(open_count + 1, close_count, current + '(')
if close_count &lt; open_count:  # Can close if more opens than closes
    dfs(open_count, close_count + 1, current + ')')
</code></pre>
<p><strong>Exercise 14: Word Search</strong></p>
<pre><code class="language-python">if index == len(word):  # Found entire word
    return True
return False  # Out of bounds or doesn't match
board[r][c] = '#'  # Mark visited
if dfs(r + dr, c + dc, index + 1):  # Explore with next index
    found = True
    break
board[r][c] = temp  # Restore (backtrack)
</code></pre>
<p><strong>Exercise 15: Number of Islands</strong></p>
<pre><code class="language-python">dfs(r + dr, c + dc)  # Explore neighbors
count += 1  # New island found
</code></pre>
<p><strong>Exercise 16: Permutations</strong></p>
<pre><code class="language-python">result.append(current[:])  # Make a copy
current.append(remaining[i])  # Add chosen number
new_remaining = remaining[:i] + remaining[i+1:]  # Remove chosen
current.pop()  # Backtrack
</code></pre>
<h2>Quiz 2 Answers</h2>
<ol>
<li>When you need to explore all paths, backtrack, or detect cycles</li>
<li>Recursive uses recursion stack, iterative uses explicit stack</li>
<li>O(V + E)</li>
<li>Remove from path and unmark</li>
<li>Inorder</li>
<li>Directed graphs need 3 states (WHITE/GRAY/BLACK) to detect back edges. Undirected graphs can use 2 states (visited/unvisited) and check if neighbor is parent.</li>
<li>We add nodes in postorder (after exploring dependencies), so they're added in reverse topological order. We reverse to get correct order.</li>
<li>Because lists are mutable and we'll backtrack, modifying the list. Without copy, all entries would reference the same modified list.</li>
</ol>
<h2>Quiz 3 Answers</h2>
<ol>
<li>All of the above - they're the same concepts with different names</li>
<li>Postorder ensures we process dependencies before dependents. After exploring all dependencies (neighbors), we add the node, ensuring it comes after all its dependencies.</li>
<li>Nodes can be added multiple times to the stack, causing duplicates and potential infinite loops in cyclic graphs.</li>
<li>When recursion depth might be too deep (stack overflow), or when you need more control over the traversal order.</li>
</ol>
<h2>Exercise 10 Answers</h2>
<ol>
<li>BFS - finds shortest path</li>
<li>DFS - backtracking problem</li>
<li>Either works, but DFS is simpler</li>
<li>BFS - level by level</li>
<li>DFS - easier to detect back edges</li>
</ol>
<h2>Exercise 11 Answers</h2>
<ol>
<li>BFS</li>
<li>DFS</li>
<li>Either (DFS is common)</li>
<li>BFS</li>
<li>Either (DFS is simpler)</li>
</ol>
<h2>Exercise 17-35 Answers (Tree Algorithms)</h2>
<p><strong>Exercise 17: Level Order</strong></p>
<pre><code class="language-python">level_size = len(queue)
node = queue.popleft()
queue.append(node.left)
queue.append(node.right)
</code></pre>
<p><strong>Exercise 18: Zigzag Level Order</strong></p>
<pre><code class="language-python">current_level.append(node.val)  # left to right
current_level.insert(0, node.val)  # right to left
left_to_right = not left_to_right  # toggle
</code></pre>
<p><strong>Exercise 19: Right Side View</strong></p>
<pre><code class="language-python">if i == level_size - 1:  # last node at level
</code></pre>
<p><strong>Exercise 20: Maximum Depth</strong></p>
<pre><code class="language-python">return 0  # base case
left_depth = max_depth(root.left)
right_depth = max_depth(root.right)
return 1 + max(left_depth, right_depth)
</code></pre>
<p><strong>Exercise 21: Minimum Depth (BFS)</strong></p>
<pre><code class="language-python">node, depth = queue.popleft()
return depth
queue.append((node.left, depth + 1))
queue.append((node.right, depth + 1))
</code></pre>
<p><strong>Exercise 22: Invert Tree</strong></p>
<pre><code class="language-python">root.left, root.right = root.right, root.left
</code></pre>
<p><strong>Exercise 23: Same Tree</strong></p>
<pre><code class="language-python">if not p and not q:  # both None
if not p or not q:  # one None
is_same_tree(p.left, q.left)
is_same_tree(p.right, q.right)
</code></pre>
<p><strong>Exercise 24: Symmetric Tree</strong></p>
<pre><code class="language-python">is_mirror(left.left, right.right)  # outer
is_mirror(left.right, right.left)  # inner
return is_mirror(root.left, root.right)
</code></pre>
<p><strong>Exercise 25: Path Sum</strong></p>
<pre><code class="language-python">return target_sum == root.val
remaining = target_sum - root.val
has_path_sum(root.left, remaining)
has_path_sum(root.right, remaining)
</code></pre>
<p><strong>Exercise 26: Binary Tree Paths</strong></p>
<pre><code class="language-python">result.append(&quot;-&gt;&quot;.join(path))
path.pop()
</code></pre>
<p><strong>Exercise 27: Path Sum II</strong></p>
<pre><code class="language-python">result.append(path[:])  # copy of path
path.pop()
</code></pre>
<p><strong>Exercise 28: Lowest Common Ancestor</strong></p>
<pre><code class="language-python">return root  # base case
return root  # both found in different subtrees
return left or right  # both in same subtree
</code></pre>
<p><strong>Exercise 29: Build Tree from Preorder/Inorder</strong></p>
<pre><code class="language-python">root_index = inorder.index(root_val)
root.left = build_tree(left_preorder, left_inorder)
root.right = build_tree(right_preorder, right_inorder)
</code></pre>
<p><strong>Exercise 30: Serialize/Deserialize</strong></p>
<pre><code class="language-python"># Already complete in template - just review the structure!
</code></pre>
<p><strong>Exercise 31: Validate BST</strong></p>
<pre><code class="language-python">return False  # invalid BST
</code></pre>
<p><strong>Exercise 32: Kth Smallest</strong></p>
<pre><code class="language-python">if count == k:  # kth element found
</code></pre>
<p><strong>Exercise 33: Count Complete Tree Nodes</strong></p>
<pre><code class="language-python">return 1 + count_nodes(root.left) + count_nodes(root.right)
</code></pre>
<p><strong>Exercise 34: Maximum Path Sum</strong></p>
<pre><code class="language-python">max_sum = max(max_sum, current_max)
return node.val + max(left_max, right_max)
</code></pre>
<p><strong>Exercise 35: Diameter</strong></p>
<pre><code class="language-python">max_diameter = max(max_diameter, left_height + right_height)
return 1 + max(left_height, right_height)
</code></pre>
<hr />
<h1>Study Checklist</h1>
<p>Use this checklist to track your progress:</p>
<h2>BFS Mastery</h2>
<ul>
<li>[ ] Can explain BFS intuitively (ripple analogy)</li>
<li>[ ] Can write basic BFS from memory</li>
<li>[ ] Can implement BFS with level tracking</li>
<li>[ ] Can implement BFS on a grid</li>
<li>[ ] Can find shortest path with BFS</li>
<li>[ ] Can identify BFS problems in interviews</li>
</ul>
<h2>DFS Mastery</h2>
<ul>
<li>[ ] Can explain DFS intuitively (maze analogy)</li>
<li>[ ] Can write recursive DFS from memory</li>
<li>[ ] Can write iterative DFS from memory</li>
<li>[ ] Can implement DFS on a grid</li>
<li>[ ] Can implement DFS with backtracking</li>
<li>[ ] Can detect cycles in directed graphs (3-state DFS)</li>
<li>[ ] Can implement topological sort using DFS</li>
<li>[ ] Can do tree traversals (inorder, preorder, postorder)</li>
<li>[ ] Can solve backtracking problems (permutations, combinations)</li>
<li>[ ] Can solve grid backtracking (word search)</li>
<li>[ ] Can identify DFS problems in interviews</li>
</ul>
<h2>Tree Algorithms Mastery</h2>
<ul>
<li>[ ] Understand binary tree structure and terminology</li>
<li>[ ] Can implement level-order traversal (BFS)</li>
<li>[ ] Can implement inorder, preorder, postorder (DFS)</li>
<li>[ ] Can find maximum depth (DFS postorder)</li>
<li>[ ] Can find minimum depth (BFS)</li>
<li>[ ] Can invert a binary tree</li>
<li>[ ] Can check if trees are same/symmetric</li>
<li>[ ] Can solve path sum problems</li>
<li>[ ] Can find all root-to-leaf paths</li>
<li>[ ] Can find lowest common ancestor</li>
<li>[ ] Can construct tree from traversals</li>
<li>[ ] Can serialize/deserialize tree</li>
<li>[ ] Can validate BST</li>
<li>[ ] Can find kth smallest in BST</li>
<li>[ ] Can find maximum path sum</li>
<li>[ ] Can find diameter of tree</li>
</ul>
<h2>Problem Solving</h2>
<ul>
<li>[ ] Can choose between BFS and DFS for a problem</li>
<li>[ ] Can implement Number of Islands (DFS)</li>
<li>[ ] Can implement Word Search (DFS backtracking)</li>
<li>[ ] Can implement Word Ladder (BFS)</li>
<li>[ ] Can implement tree traversals (inorder, preorder, postorder)</li>
<li>[ ] Can detect cycles with DFS (directed graphs)</li>
<li>[ ] Can implement topological sort</li>
<li>[ ] Can solve Generate Parentheses (DFS backtracking)</li>
<li>[ ] Can solve tree problems (max depth, same tree, BST validation)</li>
<li>[ ] Can implement permutations/combinations using DFS</li>
</ul>
<hr />
<p><strong>Good luck with your interview prep! üöÄ</strong></p>
<p><em>Remember: Practice implementing these from memory until it becomes muscle memory.</em></p>
</body>
</html>
